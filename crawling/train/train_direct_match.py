# -*- coding: utf-8 -*-
"""train_direct_match.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_6P74qJxbjnez1fEn6oOqAZCxTfHl5Ga
"""

# installing xmltodict
pip install xmltodict

# importing necessary libraries

from bs4 import BeautifulSoup
import requests, xmltodict
import urllib
from urllib.request import urlopen
import pandas as pd

# function that creates and returns one tuple for the city of origin
# and another for the city of destination
def orig2dest_tuple(origin_sido, origin_sgg, dest_sido, dest_sgg):
  return ((origin_sido, origin_sgg), (dest_sido, dest_sgg))

# function that splits a city value into two values: sido, and sgg
def split_city(city):
  city = city.split(",")
  return city[0], city[1]

# setting up train data
train_csv_github_url = "https://raw.githubusercontent.com/forrestpark/adonde.kr/main/data/train/train_id_name_sido_sgg.csv"
train = pd.read_csv(train_csv_github_url)

# setting up train city pair data
train_citypair_github_url = "https://raw.githubusercontent.com/forrestpark/adonde.kr/main/data/train/train_citypair.csv"
train_citypair = pd.read_csv(train_citypair_github_url)

# setting up city-to-stations relation
cities_with_trains = list(set(train['sido'] + "," + train['sgg']))
city2stations = {}

for city in cities_with_trains:
  city = city.split(",")
  sido = city[0]
  sgg = city[1]
  stations = train.loc[(train['sido'] == sido) & (train['sgg'] == sgg)]
  city2stations[(sido, sgg)] = stations['station_id']

# setting up train direct route table
train_route_exists = {}

n = len(cities_with_trains)

for i in range(n):
  orig_city = cities_with_trains[i]
  orig_sido, orig_sgg = split_city(orig_city)
  for j in range(i+1, n):
    dest_city = cities_with_trains[j]
    dest_sido, dest_sgg = split_city(dest_city)
    train_route_exists[orig2dest_tuple(orig_sido, orig_sgg, dest_sido, dest_sgg)] = None
    train_route_exists[orig2dest_tuple(dest_sido, dest_sgg, orig_sido, orig_sgg)] = None

# fetching train data from personal github
github_url = "https://raw.githubusercontent.com/forrestpark/adonde.kr/main/data/train/train_route_exists4.csv"
tr = pd.read_csv(github_url)
tr

# creating a train_route_exists dictionary
# train_route_exists --> keys: pair of two cities, both with at least one train station each
#                        values: 1.0 if there exists at least one direct route by train between the two
#                                0.0 if there does not exist even one direct route by train between the two

for idx, item in tr.iterrows():
  if not pd.isnull(item['routes']):
    train_route_exists[((eval(item['depCity'])), eval(item['arrCity']))] = item['routes']

train_route_exists

# API key settings

base_url = "http://openapi.tago.go.kr/openapi/service/TrainInfoService/getStrtpntAlocFndTrainInfo?ServiceKey={}&depPlaceId={}&arrPlaceId={}&depPlandTime=20210629"
jw_key = "YIG48RZ4OVNbB15tDMQv6%2FS4eDc38APYyyBkaUCB%2BnrBCbtm7l1hpnNDmVQ1p4RXGoQC7GYdXhpYgoPn%2FIzZww%3D%3D"
js_key = "IEjqLPhgSeNKrTAfRoVI%2B7UDXveTEiYz4iX7fOeZI52ICTqbEchG%2FDlEGrbhklOVF%2B%2FRHW4%2FdTkmXaXNXgwBVA%3D%3D"

keys = [jw_key, js_key]

keys.append("DrKafXvQUZuWUWrlCqV5LuOc8ydG5e4kqY%2FOYOrMnqC31uMjtVsNiUGrAtFeOuU5DTOiFyk5PCHHVYL6htP0Zg%3D%3D")
keys.append("FRwvA0%2FjetViPb6gJlRt6sy6HyUqCAhpK2UIgCRHEGSDxP3J5GZguVDAzNMGSpsySXxQAMZjOGhW0Lnn3BCvRA%3D%3D")
keys.append("1vKYx8mJcSORS7i9d%2BNllRatkNxcexJzbugUMi5R%2B3KvckxMhNYFtMFW3r%2FVm1xrXBUzfiQ70aCBmvDsudIaXw%3D%3D")
keys.append("5bzXEAG80KKE9Y6fWqpUOcwtMlpOUWLxlPUpLRzpFtYiA2S6Yd8iz30WG9MOk1T4juIDeyNqK%2FJvoCoUB16QYw%3D%3D")
keys.append("L7OZ4LHbSgTQWjD%2FP7r8Box8MCEcEN1KiUDnbu910KW7UlZsK1qOIOA5rhju%2BZjtZDRd11nr%2FTbshzaqJ3DWmQ%3D%3D")
keys.append("jL7UfxKH2%2Fqfx%2FJaq1FoZKSzhQolgN5qGIPHlD7kW86C8GwgAX%2FcWbcNep3Oi330z%2BzUsf1rePlkbrEYsquGYQ%3D%3D")
keys.append("71vq11IN2TI157FptiqGmLvETZ9pqv76NE0y7AqQHQCzCXNUDFdX%2BnqxQmDYZZnWo0mcf2NHmmnOY5A8C5aq8A%3D%3D")
keys.append("QkI8oj7L%2BgZhSumM2IY7ByN6VPYnVesvlcjiFQaiO47V7XEKfH%2BRbXTf58R%2BZHCSQzMlQtRCK9ymu9DxRM%2BITg%3D%3D")
keys.append("7%2F5ebTmaTwPxDP9HBX6tuP1EEV0VGEx%2BJ8mt7AbGRIWdGMOFssioAXBXChTMHgfldW%2BDjuW%2FjOywvs3vsr%2Bsuw%3D%3D")
# keys.append("U9SDoQbtIvXr89CBmMLWMCxx5LaX3C5di51KBBaw1MQscVqzyoYw4sjy06GG2UlCODaNZ%2F9pWjgHSAzEH%2BpRrQ%3D%3D")
keys.append("KBD%2BiKisQv%2F5Uz1Ef%2BK0kwAeSzDyoQ9FlYXNzGkKFJ9YR6Zv7PyLPZAoxo%2FNK5e21kS59a4%2BbIg3u46MTxDD3Q%3D%3D")

# keys.append("")

# function that adds the service key, train station ID of origin,
# and train station ID of arrival to the URL we'll be requesting
# returns a fully functioning API request URL
def add_terminal_ids(service_key, orig_id, dest_id):
  return base_url.format(service_key, orig_id, dest_id)

# function that checks whether a city pair is always checked
# and has value of either 0.0 or 1.0
def checkIfAlreadyTrue(dep, arr):
  if train_route_exists[(dep, arr)] or train_route_exists[(arr, dep)]:
    return True
  else:
    return False

# checks whether the value for a city pair key is still None,
# meaning the search for direct routes between the two cities has not been completed
def checkIfNone(dep, arr):
  if train_route_exists[(dep, arr)] == None or train_route_exists[(arr, dep)] == None:
    return True
  else:
    return False

# function that sends the API URL request
# uses the public OpenAPI, provided by Republic of Korea's Ministry of Land, Infrastructure, and Transport
# details about the API can be found here:
# https://www.data.go.kr/tcs/dss/selectApiDataDetailView.do?publicDataPk=15000500
def send_requests(key_idx, dep, arr, req_count):
  url = add_terminal_ids(keys[key_idx], dep, arr)
  req_count += 1
  return requests.get(url).content, req_count

# updating the value for certain city pair key in train_route_exists dictionary
def set_citypair_to(dep, arr, num):
  train_route_exists[(dep, arr)] = num
  train_route_exists[(arr, dep)] = num

# saves API-crawled data as csv file
def save_as_csv():
  print("saving as csv...")
  print(train_route_exists)
  deplist, arrlist, routelist = [], [], []
  for (dep, arr), route in train_route_exists.items():
    deplist.append(dep)
    arrlist.append(arr)
    routelist.append(route)
  data = {"depCity": deplist, "arrCity": arrlist, "routes": routelist}
  df = pd.DataFrame(data)
  df.to_csv("train_route_exists1.csv")

# checks how many city pair entries in train_route_exists dictionary have been filled so far
def check_how_many_filled():
  count = 0
  for key, value in train_route_exists.items():
    if value == 0 or value == 1:
      count += 1
      print(key, value)

  print("count: ", count)

# finds whether or not there exists at least one direct route between two cities
# calls most of the helper methods mentioned above
def find_route_matches(key_idx=0, start=0,end=len(train_citypair),req_count = 0):

  for pair in train_citypair[start:end].iterrows():
    dep, arr = eval(pair[1][1]), eval(pair[1][2])
    print("dep: ", dep, ", arr: ", arr)
    print(req_count)

    if not checkIfNone(dep, arr):
      print("continue none")
      continue

    depTerminals, arrTerminals = city2stations[dep], city2stations[arr]
      
    # for all terminals in the city of departure
    for depTerminal in depTerminals:
      # pass if we already have direct route data between the two cities
      if checkIfAlreadyTrue(dep, arr):
        print("continue")
        continue
      # for all terminals in the city of arrival
      for arrTerminal in arrTerminals:
        # pass if we already have direct route data between the two cities
        if checkIfAlreadyTrue(dep, arr):
          print("continue")
          continue

        # send requests
        print(depTerminal, arrTerminal)
        content, req_count = send_requests(key_idx, depTerminal, arrTerminal, req_count)

        dict = xmltodict.parse(content)
        while dict['response']['header']['resultCode'] != '00':
          key_idx += 1
          print("moving key index to ", key_idx)
          if key_idx == len(keys):
            save_as_csv()
            check_how_many_filled()
            print("index: ", int(pair[0]))
            return int(pair[0])
          content, req_count = send_requests(key_idx, depTerminal, arrTerminal, req_count)
          dict = xmltodict.parse(content)
          print(dict)
        dict = dict['response']['body']['items']

        # no results found --> no direct express bus route between the two terminals
        if not dict:
          print("no direct route")
          set_citypair_to(dep, arr, 0)

        # result(s) found!
        else:
          print("yes direct route")
          set_citypair_to(dep, arr, 1)

# calls the main API-crawling function
# you may update key_idx and start values
# parameters
# key_idx: sets which API key to start with
# start: index of train_route_exists to start the search from
find_route_matches(key_idx=0, start=0)

train_route_exists

# formatting the API-crawled data so that it is suitable to be exported as a csv file
deplist, arrlist, routelist = [], [], []

for (dep, arr), route in train_route_exists.items():
  deplist.append(dep)
  arrlist.append(arr)
  routelist.append(route)
data = {"depCity": deplist, "arrCity": arrlist, "routes": routelist}
df = pd.DataFrame(data)
df.to_csv("train_route_exists3.csv")